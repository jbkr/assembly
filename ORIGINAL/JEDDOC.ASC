ÉÑÑÑÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º³³³³                                                   º
º³³³³  LEARNING AND USING JED                           º
º³³³³                                                   º
ÇÅÅÅÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¶
º³³³³  A programming environment for assembly language  º
ÈÏÏÏÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼


1. A place to stand with access to tools

"Give me a lever long enough, and a place to stand, and I will
move the Earth."
     Archimedes was speaking literally about the power of the
lever, but behind his words there is a larger truth about work in
general: To get something done, you need a place to work, with
access to tools.  My radio bench in the garage is set up that
way:  A large, flat space to lay ailing transmitters down, and a
shelf above where my oscilloscope, VTVM, frequency counter,
signal generator, and dip meter are within easy reach.
     Much of the astonishing early success of Turbo Pascal was
grounded in that truth.  For the first time, a compiler vendor
assembled the most important tools of software development and
put them together in an intuitive fashion so that the various
tasks involved in creating software flowed easily from one step
to the next.  From a menu that was your place to stand, you
pressed one key, and your Pascal program was compiled.  You
pressed another one, and the program was run.  It was simple,
fast, and easy to learn.  Turbo Pascal literally took Pascal from
a backwater language favored by academics to the most popular
compiled language in history, BASIC not excluded.
     What Borland so boldly introduced in 1983 was adopted
(reluctantly at times) by their major competitor, Microsoft. 
Today, Turbo Pascal, Turbo C, Turbo Basic, Turbo Prolog, Quick C,
and Quick BASIC are what we call integrated development
environments.  They provide well-designed menus to give you that
place to stand, and a multitude of tools that are only one or two
keystrokes away.
     A little remarkably, there is no true equivalent to Turbo
Pascal in the assembly-language field.  Neither MASM nor
Borland's own Turbo Assembler have that same comfortable place to
stand.  The reasons for this may seem peculiar to you, the
beginner:  Seasoned assembly-language programmers either create
their own development environments (they are, after all, the
programming elite) or they simply work from the naked DOS prompt. 
The appeal of a Turbo Pascal-type environment is not so strong to
them as it is to you.  An integrated development environment for
MASM and TASM may happen in time, but you must understand that
both Microsoft and Borland are catering to their most important
audience, the established assembly-language programmer.
     That doesn't do much good for you.  One glance at Figure 3.5
on page XXX can give you the screaming willies.  Assembly
language development not a simple process, and grabbing all the
tools from the DOS prompt is complicated and error-prone; rather
like standing on a ball-bearing bar stool to get the shot glasses
down from the high shelf over the bar.
     So, to make things a little easier for you, I've created a
program called JED.  JED is a beginner's development environment
for either MASM or TASM.  It's nowhere near as powerful as the
environments provided with the Turbo or Quick languages, but it's
powerful enough to get you started on the long road toward
assembly language proficiency.

Laying hands on JED
JED.EXE is written in Turbo Pascal 5.0.  You can get a copy from
many of the larger user groups around the country.  Perhaps your
friends have a copy; ask around.  I've allowed people to copy it
freely in the hopes that it will be widely used.  If you can't
find it anywhere, you can order the listings diskette from me
through the coupon on the flyleaf.  Both source code and .EXE
versions of JED are included on the listings diskette.  You don't
need Turbo Pascal to run JED.EXE.  It's fully compiled and ready
to run.
     I must emphasize that not quite all of the source code for
JED is on the listings diskette.  JED contains a powerful text
editor provided with Borland's Turbo Pascal Editor Toolbox.  You
can get JED's source code from the listings diskette, but keep in
mind that it's not all there; you must buy the Turbo Pascal
Editor Toolbox and own Turbo Pascal 5.0 in order to compile or
modify JED.
     

2. JED's place to stand

Like Turbo Pascal and the other integrated development
environments from both Borland and Microsoft, JED's most visible
part is a text editor.  If you'll look back once again to Figure
3.5, you'll see that all roads seem to lead back to the text
editor in good time.  In general, you do most of your thinking
while staring at the text editor screen, so it seems a logical
location to put your place to stand.
     Running JED is easy.  The first time you want to work on a
particular source code file, you type the name JED followed by
the name of the source code file:

C:\ASM>JED EAT2.ASM

JED will be loaded from disk and run by DOS, and then JED will
load the text file EAT2.ASM from disk into its editor workspace. 
You'll get a view like that shown in Figure 1.

         <INSERT Figure 1. JED's edit screen JEDED.SCR>


The status line
Apart from the very top line, everything on the screen is a
display of your text file.  This top line, the status line,
contains several important items of information about the file
JED loaded at startup, which is called the current file.  The
first two items tell you the position of the cursor in terms of
line number and column number.  In case you're unfamiliar with
such things, the line numbers run from top to bottom with line 1
at the top, and column numbers run from left to right, with
column 1 at the left margin.  As you move the cursor around the
file using the cursor control keys (see Section 4) the position
of the cursor will be constantly updated in the status line.
     The word Insert will be present in the status line if JED's
editor is in insert mode, meaning that character typed at the
keyboard will be inserted at the cursor position, "pushing aside"
the characters to the right of the cursor position.  When the
word Insert is not present, JED's editor is in overwrite mode,
meaning that characters typed at the cursor position will be
placed atop characters that already exist on the screen, and that
those underlying characters will be lost.  I'll say more on this
item later in this chapter.
     Similarly, the word Indent indicates that the editor is in
indent mode.  In indent mode, indenting one line by spacing over
from the left margin will cause subsequent lines to automatically
indent to the same number of spaces from the margin.  Again, more
on this later in this chapter.
     The name of the current file is present in the status line. 
Finally, the current time of day as present in DOS's clock is
shown in the upper right hand corner of the screen.

The prompt bar
At the bottom of the screen, highlighted in blue (if you have a
color screen) is a single line bar that summarizes most of JED's
important commands.  This bar is called the prompt bar.  It
provides always-visible reminders as to which tools are at your
grasp while you are standing at JED's edit screen.  Each tool is
invoked by pressing one of the PC's ten function keys.
     Eight of the ten function keys are summarized in the prompt
bar.  The two that are not present, F7 and F8, are actually text
editing commands, and will be discussed along with all of the
other editing commands in Section 4.

JED's help screen
Perhaps the single most important command to remember while
you're still a beginner is the Help command, F1.  Pressing F1
instantly brings up a 24-line help display of all JED commands
and most of the text editing commands.  If you ever forget a
command or are unsure of what one of the prompt bar reminders
means (like F4:Cmds, which is something less than obvious) simply
press F1 and read the available information.  JED's help screen
is shown in Figure 2.

        <INSERT Figure 2. JED's help screen JEDHELP.SCR>

     Once the help screen is displayed, you can put it away and
return to the editing screen by pressing any non-shift key. 
(That is, any key but the Shift, Ctrl, or Alt keys.)


3. Using JED's tools

The very best way to explain JED's commands and how they are used
is to run through a simple JED session with a real assembly
language program and explain what happens as we go.  The program
we'll use is EAT2.ASM, which is shown in Section X.X on page XXX. 
It's not much of a program, and exists only to get you started in
understanding the internal mechanisms of a real, working assembly
language program.  When run from the DOS prompt, EAT2.EXE
displays this simple message on your screen:

Eat at Joe's...
...ten million flies can't ALL be wrong!


After it displays those two lines, it ends and returns control to
DOS.
     EAT2.ASM is the source code file from which the executable
program file EAT2.EXE is assembled and linked.  EAT2.ASM is
present on the disk with JED.
     If, as I have suggested earlier, you have created a
subdirectory on your hard disk called ASM, copy all of the files
on the JED disk into subdirectory ASM.  In order for JED to
operate correctly, the following files must be present in the
subdirectory with JED:

     1. Your assembler.  This can be any command-line
     oriented assembler, but will typically be either
     MASM.EXE (Microsoft's Macro Assembler) or TASM.EXE
     (Borland's Turbo Assembler.)  

     2. Your assembler's linker.  Assemblers are usually
     shipped with their own linker.  This is certainly true
     of MASM and TASM.  Some assemblers may not use their
     own linker, but will use the DOS linker LINK.EXE
     instead.

     3. The DOS debugger, DEBUG.COM.  Some versions of DOS
     are no longer shipped with DEBUG, which is offered as
     part of an additional utilities disk.  Prior to DOS
     3.2, all versions have DEBUG.COM.  

     Of course, other files can be present without any hindrance
to your work.

Invoking JED
Make the current directory your working assembly language
subdirectory, which I have suggested you call ASM.  From the DOS
prompt, invoked JED with the file name EAT2 after it:

C:\ASM>JED EAT2

Notice that you don't have to type the .ASM at the end of the
file name EAT2.  JED has a default file extension of .ASM.  In
other words, if you don't enter a file extension, JED will append
the file extension .ASM on end of the name you enter on the
command line.  You could, of course, have entered the full file
name including extension if you chose:

C:\ASM>JED EAT2.ASM

JED will in either case consider the name of the current file to
be EAT2.ASM.
     Now, either EAT2.ASM exists on your disk or it doesn't.  JED
won't mind if the file doesn't exist--new files have to start
somewhere!.  If JED can't find the file whose name you enter on
the command line, it will display the words "New file" in the
upper left corner of the screen while it creates an empty text
file on your hard disk.  When you type text into the text editor
screen, JED will save the text into that new file.
     The file may well exist on disk, and if it does, JED will
load the file into the editor screen and display it for you. 
Assuming you entered the name EAT2, the screen should look almost
identical to that shown in Figure 1.
     You might wonder what will happen if you simply type JED at
the DOS command line without specifying any file name at all for
it to work on.  One of two things will happen:

     1. JED will load the file that you last worked on from
     within JED.  JED keeps a record of the last file it
     loads and saves in a small file on disk named JED.CFG. 
     If it can find JED.CFG, and if the file named in
     JED.CFG is in your working subdirectory, JED will load
     that file.  JED updates JED.CFG automatically, and you
     don't need to worry about updated JED.CFG.

     2. If there is no JED.CFG on your disk, JED will create
     a file imaginatively named NONAME.ASM and store your
     text into a new file with that name.  NONAME.ASM is a
     pretty rank name for any assembly language program, so
     while it will be saved as a perfectly good file, you
     might as well think of a better name and enter that
     when invoking JED.

     JED's remembering the name of the last file you worked on
makes it unnecessary for you to remember what project you were in
the middle of when you pulled the plug and went to bed. 
Furthermore, JED also remembers the cursor position where the
cursor was when you saved your file and exited from JED.  Simply
type JED, and JED will bring up the correct file and allow you to
continue at the exact cursor position where you left off.

Moving around within the editor
Your place to stand is JED's text editor, and when nothing else
is going on (like assembling, linking, debugging, or running your
program) you'll be in the text editor.
     When you're in the text editor, any characters you type on
the keyboard will be inserted into the current file and displayed
on your screen.  You can move the cursor around within the
current file by using any of a number of cursor movement keys.
     The easiest to remember are the PC's cursor keypad keys. 
The four arrow keys will move the cursor one character position
in the direction the arrow points.  The PgUp key will move the
cursor one page (i.e., the size of your screen; typically 25, 43,
or 50 lines) up, whereas PgDn will move the cursor one page down. 
The Home key will move the cursor immediately to the left screen
margin, and the End key will move the cursor immediately to the
end of the current line.  (The "end of the line" is defined as
the character after the rightmost non-blank character in the
line.)
     There are numerous other cursor movement keys that you can
use within JED.  I'll describe them all in detail in Section 4.
     Take a few moments scooting around inside EAT2 until you
feel comfortable with it.

Making changes to the file
The simplest way to change the file is simply to type something
at the keyboard.  All such characters will appear at the cursor,
and the cursor will move one position to the right for each
character.
     You can insert a new line beneath the current line by
pressing Enter.
     Getting rid of unwanted text is as important as adding new
text.  Deleting one character at a time can simply be done by
moving the cursor to the immediate right of the offending
character, and simply using the backspace key to back the cursor
over it.  The character will disappear.
     You can delete an entire line by placing the cursor on the
line and pressing Ctrl-Y.  This can be done all too easily by
accident, and lose a line that you may or may not have in your
head or written down on paper.  Be careful!
     JED contains numerous other ways to delete text, all of
which will be described in Section 4.  For the sake of the
current guided tour through JED, move the cursor to the blank
line immediately beneath EAT2's comment header (line 9 in the
file) and type the word "FOO".  That done, press Enter and add a
new line beneath it.

Saving changes to a file
As they say in Chicago, that grand old (and cold) town where I
grew up, "Vote early and often."  The same philosophy applies to
saving the changes you make to your current file under JED. 
Every so often, perhaps when you kick back in your chair to think
for a bit, save your work.  It's easy:  One keystroke, the
function key F2.  JED will display the word "Saving..." in the
status line at the top of the screen while it saves your file to
disk.  If you have a fast hard disk this will rarely take more
than a second.  If you're still working on diskettes, the process
may take a few seconds more, especially if the current file is a
good size.
     Get in the habit of pressing F2 once in a while.  Keep in
mind that if you save your work every five minutes, you will
never lose more than five minutes of work!
     JED keeps an eye on things and does its level best to keep
you from losing any of your work.  If you try to exit JED without
saving your file to disk, JED will remind you with the following
prompt:

File modified.  Save it? (Y/N)

If you press "Y", JED will save your work to disk.  Pressing "N"
will allow you to exit JED without saving your work.  All other
keys but "Y" and "N" will be ignored.
     JED also automatically saves your work every time you go out
to use the assembler, linker, or debugger, or when you run the
program you're developing, as I'll explain a little later.

Changing the current file
If you want to change the current file while you're in JED and
working, simply press Alt-F.  (Think: File.)  A window will
appear in the center of the screen, and display the name of the
current file above a field where you can enter the name of the
new file.
     The name of the current file will be in the field.  You can
do one of two things to the name:

     þ Begin typing a new name.  The old name will vanish as soon
     as you press a printable character key.

     þ Backspace over some portion of the old name.  This would
     allow you to change the name of the current file from
     EAT2.ASM to EAT3.ASM without typing the whole name.

When you press Enter, JED will attempt to load the file whose
name you typed.  If the file does not exist, or if the name field
was blank, JED will create a new file according to the rules
summarized in the previous section.

Checking and changing the assemble and link commands
The whole point of JED is to help your work in assembly language,
and the central task in assembly language work is processing a
correct file through an assembler.  JED can execute your
assembler program and assemble your current file with only one
keystroke on your part.  That keystroke is function key F9, as
you'll see from the prompt bar at the bottom of the screen. 
Before you press F9 on our tour, however, we'd better make sure
JED has your assembler and linker commands straight.
     As programs go, JED is pretty clever, but it doesn't read
minds.  It can make use of any assembler that operates from the
DOS command line, but you have to tell JED how to invoke the
assembler you've chosen.  MASM and TASM are invoked in different
ways, and JED must know which assembler you're using to be able
to call the assembler program from disk and make use of it.
     This is done with yet another JED command.  Press function
key F4, and a whole new screen will appear, as shown in Figure 3.

 <INSERT Figure 3.  Changing JED's assembler and link commands>

JED contains two command lines, one which invokes your assembler,
and another which invokes your linker.  I've set JED up to assume
the use of Borland's Turbo Assembler TASM, which is faster and in
many ways more sophisticated than Microsoft's MASM.  If you are
using TASM, you needn't change JED's built-in default command
lines.  Figure 3 shows the default command lines for TASM.
     To use MASM or some other assembler, however, you'll need to
change both command lines.  This will require some knowledge of
how your assembler and linker operate.  I'll provide you with
some basic information about MASM and TASM; for other assemblers
(or for using specialized features of MASM and TASM) you're on
your own.
     The line beneath the prompt "Assemble command" is the line
JED will use to invoke your assembler.  The default is

TASM ~

which will invoked Borland's Turbo Assembler with all default
conditions in force.  The tilde character "~" is used to indicate
where in the line JED is to substitute the name of the current
file.  In other words, when JED goes out to DOS to execute TASM
on the file EAT2.ASM, it will substitute the name "EAT2.ASM" for
the tilde, and use this actual line for invoking TASM:

TASM EAT2.ASM

     If you're using MASM instead, the assemble command line must
be changed.  Invoking MASM with all defaults in force (using the
tilde to indicate the position of the file name) requires this
command line:

MASM ~;

Again, in our example this would be expanded to 

MASM EAT2.ASM;

The semicolon is very important, and prevents MASM from going
into interactive mode.  If you omit the semicolon, MASM will stop
and begin asking questions from the keyboard.  JED is not
equipped to answer these questions, and while you yourself could
answer MASM's questions from the keyboard, there's no point to it
if all we want to do is use MASM's defaults.  If you're using
MASM, make sure you have that semicolon!
     Modifying the command line isn't difficult.  You can
backspace over the existing command line and replace it with a
new one, or zap the whole line at once by pressing Ctrl-X.  Then,
once the command line is empty, you can type in your new command
line.
     When the changes are the way you want them, press Enter to
retain the changes and record them in JED.CFG.  If somehow you
change your mind after zapping or otherwise altering the existing
command line, you can abandon your changes and leave the original
command line untouched by simply pressing Esc.
     You'll notice that while you're editing a command line, a
line of periods runs from the end of the command line to the
right margin.  These periods indicate how large the command line
can be.  You can type as far as the periods allow.  If you try to
type further, JED will quite literally say "uh-uh."  Try it and
see!
     Changing the link command line is done the same way.  TASM's
link command line is this:

TLINK ~

MASM's link command line, on the other hand, requires a
semicolon, and for the same reasons mentioned before:

LINK ~;

     These are the absolute simplest command lines possible, and
will suffice for simpler learning programs like EAT2.ASM.  For
more advanced work you may need to use assembler or linker
options, which are additional commands that provide special
information to the assembler or linker about the job at hand.
     For example, under MASM you can specify that the assembler
write the program's segments to disk in alphabetical order (don't
mind for now if you don't know what that means) by using the /A
option.  This requires that you enter the /A option onto the
assemble command line:

MASM /A ~;

     Both TASM and MASM have numerous options of this type.  You
won't need any of them while you're just getting started.  Later
on, when you graduate to larger and more sophisticated assembly
language work, you will need to understand and use these options. 
If you continue to use JED at that stage, you'll have to add the
desired options to the assemble and link command lines.

Assembling the current file
If you're satisfied that the assemble and link command lines are
correct, it's time to assemble EAT2.  Press function key F9.  The
following things will happen:

     1. JED will save the current file to disk, as a safety
     measure.  Any time JED transfers control outside of
     itself (by executing the program under development or
     one of the utilities) it does this.

     2. The screen will clear.  JED will invoke your
     assembler using the assemble command line described in
     the previous subsection.  The assembler will display
     its copyright notice and certain other information on
     your screen.  (Precisely what depends on the
     assembler.)  This includes error messages, if your
     source code file contains errors.

     3. When the assembler is finished, JED saves the
     contents of the screen onto the heap so you can bring
     the information (typically error messages) back for
     examination later on.  This happens invisibly and takes
     almost no time.

     4. Finally, a prompt reading "Press any key to return
     to JED" will appear at the center of the bottom line of
     the screen.  JED will wait for any keystroke, allowing
     you to take your time about reading the displayed error
     messages.  When you're ready to resume work, press a
     key and the editor screen will reappear.  An example of
     the screen at this point is shown in Figure 4.

     If you recall, you made a change to EAT2.ASM a little
earlier, by typing the word "FOO" on line 9.  This word at this
location in the file means nothing, and it will generate an
assembler error message.  You can see this error message as TASM
presents it, along with TASM's copyright notice and other
information, in Figure 4.  TASM calls the word "FOO" an "illegal
instruction" because no instruction in the 86-family instruction
set is named FOO.  If you misspelled a genuine instruction (say,
by fumble-fingering MOV into MVO) you would most likely see the
same error message.

            <INSERT Figure 4.  A TASM error message>

     Both MASM and TASM are helpful in that they identify the
line where they first noticed an error.  This time, the error is
a pretty obvious one and no assembler should have any trouble
telling you that the problem exists in line 9 of the source code
file.  Once you press a key and return to JED's edit screen, move
to line 9 and delete the offending line containing "FOO."  Just
press Ctrl-Y and the line will vanish.  Save the repaired file by
pressing F2.  Finally, invoke the assembler again by pressing F9
once more.  This time you won't see any error messages.

MAKEing an executable file, and running it
What, exactly, does running the assembler actually accomplish? 
By itself, not much.  Invoking the assembler alone is useful to
determine if there are any errors in your source code file.  If
the file contains no errors, you still don't have a runnable
program after the assembler has done its job.  What you do have
is a relocatable object file, with the same name as the current
file but with a file extension of .OBJ.  In our example here, the
assembler read in the current file EAT2.ASM and produced the new
file EAT2.OBJ.
     You can't run EAT2.OBJ, and you can't read it or print it. 
You can't do much of anything with it, in fact, but link it.  As
I explained in the previous chapter, linking is a process by
which one or more .OBJ files are translated into an executable
program file with an .EXE extension.  It's called "linking"
because more than one .OBJ file can be combined into a single
.EXE file through the linking process.  However, even if you only
have one .OBJ file (as we do here with EAT2) you must still
perform the link step on it to create an executable program file.
     JED can perform the link step very easily.  It does not,
however, perform the link step all by itself.  Running the
assembler alone is useful to identify errors, but running the
linker alone is pretty pointless unless you intend to run the
executable program file produced by the link step.  JED combines
the link step with the step of actually running your new assembly
language program to see what it does.  Furthermore, it performs
the assemble step again, so that you can do it all in one
keystroke:  Assemble, link, and away you go!
     When you press function key F10, JED will do very much what
it did when you pressed F9, and then some:

     1. JED saves the current file to disk.  The first time
     you run any new assembly language program, you had
     better prepared to reboot your machine.  It happens to
     the best of us now and then, and it will happen to you
     with a disturbing frequency.  Because we humans
     sometimes forget to save the source before running the
     .EXE file, JED never forgets.

     2. JED executes the assembler, and if there are no
     errors in the file produces an .OBJ version of the
     current file.  If errors are detected, no .OBJ file is
     generated and JED immediately takes control back from
     the assembler.  The link and go steps are not taken. 
     JED will wait for a keystroke so that you can stare at
     the error messages for awhile.

     3. If there were no assembler errors, JED executes the
     linker.  The .OBJ file is translated into a .EXE file. 
     Again, there is the possibility that linker errors will
     occur, although they are much less common than
     assembler errors.  If errors are detected, JED takes
     control back directly from the linker and the .EXE file
     will not be run.  In the event of an error, JED waits
     for a keystroke so that you can examine the wreckage
     before pressing a key and going on.

     4. The .EXE file produced by the linker is executed. 
     Your fledgling program runs, and when it finishes JED
     will once again wait for a keystroke so that you can
     examine your program's output.  In our test case of
     EAT2, this output consists of those two lines of text
     shown earlier about eating at Joe's.

     At this point, I have a confession to make.
     What I just told you was the truth, but not the whole truth. 
The F10 command is a little more complicated than just those four
steps.  Suppose, for example, that you use the F10 command to
create and run an .EXE file as we just did.  Then suppose that
you wanted to see it work again almost immediately, without
making any further changes to the program.  You press F10,
expecting to have to wait through the assemble and link step
again.
     But no...
     The second time you press F10, the .EXE file executes
immediately, with neither the assembler nor the linker doing
their thing.
     What gives?
     JED is pretty clever after all.  Since you didn't make any
additional changes to the source file, there was no need for JED
to re-assemble and re-link to recreate an .EXE file no different
from the one created a few seconds earlier.  JED therefore simply
executed the .EXE file as it did the first time, without making
you wait through a needless assemble step and link step.
     Here's what happens:  When you press F10, JED looks at two
files on disk.  The first one is the .EXE file.  If no .EXE file
exists on disk, obviously, JED has to create one by executing
both the assembler and the linker.  But if the .EXE file does
exist, JED looks at the file's time stamp and stores a copy of
the time stamp.
     A time stamp is DOS's way of knowing when a file was last
changed.  Every file created under DOS has both a time and a date
attached to it.  When you execute a DIR command from the DOS
command line, the files listed tell you when they were last
changed by displaying their time stamps as date and time values:

 Volume in drive C is DISK1_VOL1 
 Directory of  C:\TURBO\JED

JED      BAK    27659   1-08-89   4:39p
JED      PAS    27633   1-08-89   4:39p
JED      EXE    31920   1-08-89   4:39p
JED      CFG      326   1-08-89   5:25p
        4 File(s)  10803200 bytes free

The two rightmost columns are the date and time portions of each
file's time stamp.
     Once it stores a copy of the .EXE file's time stamp, JED
examines the current source code .ASM file, and stores a copy of
its time stamp.  Once JED has both time stamps, it compares them.
     If the .ASM file's time stamp shows a time more recent than
the .EXE file's time stamp, JED re-creates the .EXE file by
invoking both the assembler and the linker.  If the .ASM file's
time stamp says the .ASM file is older than the .EXE file, JED
simply runs the .EXE file without re-creating it.
     Think about that for a moment until it makes perfect sense. 
(It's important!)  If the .ASM file is older than the .EXE file,
there is no possibility that changes made to the .ASM file have
not been reflected in the .EXE file.  However, if the .ASM file
is newer than the .EXE file, it might mean that changes were made
to the .ASM file that have not yet been reflected in the .EXE
file. JED therefore updates the .EXE file so that it is
guaranteed to reflect all possible changes made in the source
code .ASM file.
     This process is a common one among software development
tools.  The name of the process is "make," meaning that when
necessary, JED will choose to "make" the .EXE file from the .ASM
file by invoking the assembler and the linker.  The make process
is efficient because it only happens when it has to.  If the .EXE
file is found to be up-to-date, the assemble and link steps are
skipped.
     As I've hinted before, running a brand new assembly language
program is dangerous business, especially for new assembly
language programmers.  High-level languages like Pascal and C
protect you to a considerable extent from your own ignorance. 
Assembly language offers almost no such protection.  Until you
really really know what you're doing, your assembly language
programs will crash your machine hard more often than they let it
live.  (This is why most assembly language programmers choose
machines with hard-reset buttons on the front panel.  Pushing
RESET is much gentler on the machine than turning it off and on
again.)
     So don't get discouraged when you crash.  As that old
Desiderata poem on your Day-Glo '60's psychedelic posters takes
pains to point out, "No doubt the universe is unfolding as it
should."  Crashing is part of the process.  What is stupid is
crashing again and again without knowing why.  Figuring out why
you're crashing is one of the most difficult and rewarding facets
of assembly language programming, as we'll see by and by.

Taking another look at your error messages
The assembler won't give you a lot of clues as to where you went
wrong when it detects an error, so you have to make the most of
what clues you get.  The assembler displays error messages during
the assemble step.  It would be handy to keep those error
messages around and refer to them when you're back in JED's
editor, staring at your errant source code.
     JED can do it.  Before JED clears the assembler's error
messages from the screen and returns you to the text editor, it
saves the screen information in memory.  Later on, you can re-
display the screen as it was immediately after the assemble step
by pressing F6.
     The only time this system fails a little bit is if you have
so many errors in the source code file that they begin to scroll
off the top of the screen.  This means, first of all, that you
have some wholesale error hunting to do.  But there is a way to
avoid losing the first few error messages of a multi-error
assemble step.  As soon as the first few error messages appear,
halt the assemble step by pressing Ctrl-C.  It's wise to treat
the first error messages first, because error messages sometimes
breed other error messages, and getting rid of the first one
might well purge five or fifteen others further down the file.
     If you try to recall an error message screen before running
the assembler, JED will clear the screen and explain the
situation.
     You should also keep in mind that if an assemble step occurs
without errors, you will still be able to recall the assembler's
copyright notice and status information by pressing F6.  JED is
not particular; whether errors occur or not, it saves the screen
from the last time the assembler was run.

Running DEBUG
An important part of developing assembly language programs is
using the DEBUG utility.  JED can run DEBUG for you with a single
keystroke.  Once you've produced a working EAT2.EXE file, press
F3.  JED will invoke DEBUG.COM with your current .EXE file as its
parameter.  DEBUG will execute and in turn load your .EXE file
into memory.  The screen will clear, and you'll see DEBUG's terse
little dash prompt.
     Press D, and DEBUG will dump the first 128 bytes of EAT2.EXE
as it was loaded into memory.  Press R, and debug will show you
the current state of the registers.  You can actually run
EAT2.EXE by pressing G (for Go) at DEBUG's prompt.  Finally, you
can quit DEBUG by pressing Q.  JED will take back control and
wait for one final keystroke so you can grab a last look at what
DEBUG had displayed.
     One additional feature is that the last screenful of
information displayed by DEBUG is saved in memory by JED, and can
be recalled by pressing F6, just as with assembler error screens. 
This is handy when you need to refer back to a hex dump of a
region of memory while examining a berserk source code file in
the editor.

"Ducking out" to DOS
For all that it does do, JED is a modest program and doesn't try
to do everything.  I was tempted to build printer support into it
so that you could create a printed listing of the current file by
pressing a single key, but decided against it.  There are a
multitude of different kinds of printers out there, each with its
own font sizes and setup strings and control sequences.  Rather
than try to cover all the printer bases, I decided to build a
quick "trap door" into JED so that you can quickly "duck out" to
DOS and run your own listing program, or do anything else that
can be done from DOS.
     This is done by pressing F5.  JED will (to be safe) save the
current file out to disk, but then it will clear the screen and
drop you back out to the DOS command prompt.  It looks very much
like JED has terminated and returned control to DOS, but not so: 
JED is very much alive in memory, waiting patiently for you to
finish your business with DOS and come back home.
     From DOS you can do things like search the directory for a
lost file, make room on your disk be erasing some clutter, or
even (in a pinch) running another major program like Turbo
Pascal.  The only caution here is that JED and your program take
up a certain amount of memory, memory that is therefore not
available to other programs like Turbo Pascal.  Very large
programs like Ventura Publisher or Paradox may not execute at all
if you try to execute them from "beneath" JED, not because you've
done anything wrong but only because such large programs need the
memory JED is taking up.
     By actual examination using the CHKDSK utility, I've found
that JED and its workspace take up about 180K of RAM.  That's a
lot of RAM, and you have to take its loss into account when you
try to do things with JED waiting in memory.
     Getting back into JED is easy.  Just type the command EXIT
at the DOS command prompt.  JED will instantly take you back with
open arms, and you can continue work as though you had never
taken a DOS break at all.
     One interesting thing to do:  Create and run a .EXE file by
pressing F10, then duck out to DOS by pressing F5, and erase the
.EXE file.  Once you return to JED, immediately press F10 again. 
Even though you made no additional changes to the source code
file, JED will search for the .EXE file before attempting to run
it.  If no .EXE file can be found, JED has no choice but to re-
make it.


4. JED's editor in detail

As JED's beating heart, the text editor deserves a little space
all to itself.  JED's editor is the Borland Binary Editor,
essentially the same editor as used in the Turbo languages and
Sidekick.  Borland disengaged the editor module from its other
products and made it available in linkable form (essentially one
of those .OBJ files I described a while back) and placed it in
the Turbo Pascal Editor Toolbox.  If you own the Turbo Pascal
Editor Toolbox, you can read up on the Binary Editor's many
commands in the Editor Toolbox documentation.  I'll describe them
all briefly in this section.

Loading files into the editor
When you invoke JED and it begins running, it loads either file
you named on the command line, or else the last file it worked
on, as recorded in JED.CFG.  The file is loaded into an area of
memory called the editor workspace.  The editor workspace is
limited to 64K in size, and any file to be loaded must fit into
memory in its entirety.  If the file is too large to fit in
available memory, you will see this message:

Insufficient text buffer size

JED will then have no choice but to throw up its hands and return
to DOS.  You'll have to cut the monster file up into smaller
files (which is a good idea anyway) and invoked JED again on only
a portion of the oversize file.
     Also keep in mind that individual lines within an edit file
are limited to 248 characters.  Loading a file with longer lines
will cause the editor to insert hyphens at the 248-character
point.

Moving the cursor
Apart from the keypad keys and function keys F7 and F8 (used for
marking text blocks, as I'll explain below) all editor commands
are control keystrokes.  That is, you must hold the Ctrl key down
while pressing another key or two keys.  All of the keys that
control cursor movement are grouped together for you in a cluster
toward the left hand side of the keyboard:

          W   E   R
        A   S   D   F
          Z   X   C


This arrangement of cursor command keys will be familiar to
anyone who has worked with the WordStar word processor.

One character at a time
Moving the cursor one character at a time can be done in all four
directions:

CTRL-E or Up Arrow moves the cursor Up one character.
CTRL-X or Down Arrow moves the cursor Down one character.
CTRL-S or Left Arrow moves the cursor Left one character.
CTRL-D or Right Arrow moves the cursor Right one character.

The position of these four keys (E, X, S, and D) provide a hint
as to which way they move the cursor.  Look at how they are
arranged on the keyboard:


              E    
            S   D    
              X    

          
     Until the directions become automatic to your fingers (as
they will, if you do enough editing!) thinking of the "magic
diamond" will remind you which way the cursor will move for which
keypress.
     When you move the cursor to the bottom of the screen and
press Ctrl-X one more time, the screen will scroll.  All the
lines on the screen will jump up by one, and the top line will
disappear.  As long as the cursor is on the bottom line of the
screen and you continue to press Ctrl-X, the screen will scroll
upward.  If use Ctrl-E to move the cursor back in the opposite
direction (upward) until it hits the top of the screen, further
Ctrl-E's will scroll the screen downward one line per Ctrl-E.

One word at a time
JED will also move the cursor one word at a time to the left or
right:

CTRL-A or CTRL-Left Arrow moves the cursor Left one word.
CTRL-F or CTRL-Right Arrow moves the cursor Right one word.

More hints are given here, since the A key is on the left side of
the magic diamond, and the F key is on the right side of the
magic diamond.

One screen at a time
It is also possible to move the cursor upward or downward through
the file one whole screen at a time.  "Upward" in this sense
means toward the beginning of the file; "downward" means toward
the end of the file.  A screen is the height of your CRT display
(25, 43, or 50 lines, depending on what display adapter is
installed and what font is currently loaded) minus two lines for
the editor status line at the top and JED's prompt bar at the
bottom.

CTRL-R or PgUp moves the cursor Up one screen.
CTRL-C or PgDn moves the cursor Down one screen.

Moving the cursor by scrolling the screen
I have described how the screen will scroll when you use the
one-character-at-a-time commands to move upward (Ctrl-E) from the
top line of the screen or downward (Ctrl-X) from the bottom line
of the screen.  You can scroll the screen upward or downward no
matter where the cursor happens to be by using the scrolling
commands:

CTRL-W scrolls the screen Down one line.
CTRL-Z scrolls the screen Up one line.

When you scroll the screen with these commands, the cursor
"rides" with the screen as it scrolls upward or downward, until
the cursor hits the top or bottom of the screen.  Then further
scrolling will make the screen "slip past" the cursor.  The
cursor will always remain visible.
     These are all of the cursor movement commands which may be
invoked by one Ctrl keystroke.  There are a few more that are
accomplished by holding the Ctrl key down and pressing two keys
in succession.  You must hold the Ctrl key down through both
keypresses!

Moving to the ends of the line
No matter where your cursor is on the screen, it is always within
a line, even if that line happens to be empty of characters. 
There are two commands that will move the cursor either to the
beginning (left end) of the line (screen column 1) or to the end
of the line, which is the position following the last visible
character on the line:

CTRL-Q/S or Home sends the cursor to the Beginning of the line.
CTRL-Q/D or End sends the cursor to the End of the line.


Moving to the ends of the file
The last set of cursor movement commands we'll describe takes the
cursor to the beginning of the file or to the end of the file. 
If the file you are editing is more than a few screens long, it
can save you a great deal of pounding on the keyboard to move one
screen at a time.

CTRL-Q/R or CTRL-PgUp sends the cursor to the Beginning of the 
file.
CTRL-Q/C or CTRL-PgDn sends the cursor to the End of the file.

     Because all of the current file is in memory all of the
time, moving between the ends of the file can be done very
quickly.


The editor status line
At the very top of JED's editor screen is the editor status line,
and it provides you with some important information while you are
editing.
     A typical instance of the status line looks like this:

Line 1    Col 1   Insert Indent     C:EAT2.ASM             09:04:45

While you were moving the cursor around, the line and column
numbers were continually changing to reflect where the cursor was
in the file.  The column number reflects the position of the
cursor within its line; the line number indicates which line in
the file contains the cursor, counting from the beginning of the
file, not from the top of the screen.  At the other end of the
status line is the name of the current file.
     The other words (Insert and Indent) shown as part of the
status line merit some explaining.  Insert and Indent are the
names of two toggles.  A toggle is a condition which may exist in
one of two different states.  A toggle is like a switch
controlling the lights in a room; the switch may be either on or
off.
     Insert determines how newly typed characters are added to
your work file.  When Insert is on (that is, when the word Insert
appears in the status line) characters which you type are
inserted into the file.  The characters appear over the cursor
and immediately push the cursor and the rest of the line to the
left to make room for themselves.  The line becomes one character
longer for each character which you type.  If you press Enter,
the cursor moves down one line, carrying with it the part of the
line lying to its right.
     When Insert is off (i.e., if the word Insert is not
displayed in the status line) characters which you type will
overwrite characters which already exist in the file.  No new
characters are added to the file unless you move the cursor to
the end of the line or the end of the file and keep typing.  If
you press Enter, the cursor will move down to the first character
of the next line down, but nothing else will change.  A line will
only be added to the file if you press Enter with the cursor on
the last line of the file.
     Turning Insert on and off is done with a single control
keypress:

CTRL-V toggles Insert on and off.

     Indent is also a toggle.  It indicates whether JED's
auto-indent feature is on or off.  When Indent is on, the cursor
will automatically move beneath the first visible character on a
new line when you press Enter.  In other words, (assuming that
Indent is on) given this little bit of text on your screen:


Adjust:
        MOV AX, [BP] + 6
        SUB AX, Increment_   <--Before pressing Enter
        _

        ^ 
        | After pressing Enter


The cursor is at the end of the last line of text.  When you
press Enter, the cursor will move down one line, but it will also
space over automatically until it is beneath the S in SUB.  This
allows you to begin typing the next line of code without having
to space the cursor over so that it is beneath the start of the
previous line.
     Like Insert, Indent can be toggled on and off.  It takes a
double control keystroke to do it:

CTRL-Q/I toggles Indent on and off.

Indent is considered on when the word Indent appears in the
status line.

Tab mode
The editor status line also displays the current tab mode.  What
we call tabbing is the automatic spacing to the right upon
pressing of the Tab key.  On the PC's keyboard, there is no key
with the word "Tab" on it; instead, the key is imprinted with two
arrows pointing in opposite directions, with a vertical bar at
the head of each arrow:

|<--
-->|

Some clone keyboards do include the word "Tab;" IBM's do not.  It
is usually positioned directly over the Ctrl key.
     There are two kinds of tabs in JED's editor.  The default
tabs are not tabs as most people knew them prior to the onset of
Borland's Turbo Pascal.  These "smart" tabs move the cursor to
the position beneath the start of the next word on the previous
line.  I.e., if you had the following line on your screen with
the cursor on the line beneath it, the caret marks show where the
cursor would pause at each successive press of the Tab key:

Think of it as evolution in action...
      ^  ^  ^  ^         ^  ^

This tabbing is done by inserting spaces, not by inserting the
ASCII Tab (Ctrl-I) character.
     Smart tabs as described above are the default tab mode in
the editor.  Pressing Ctrl-O/T toggles to the opposite tab mode,
which supports true, 8-character fixed tabs that insert Ctrl-I
characters at each press of the Tab key.  If fixed tabs are in
effect, the word Tab will be shown on the status line between the
word Indent and the filename:

Line 1    Col 1   Insert Indent Tab C:EAT2.ASM             09:45:07

In summary on tab mode,

CTRL-O/T toggles between Smart Tabs and Fixed Tabs.

Inserts and deletes
We've already seen how to insert characters into a text file: 
You make sure Insert is on, and type away.  Each typed character
will be inserted into the file at the cursor position.
     It is also possible to insert entire blank lines.  One way,
of course, is to move the cursor to the beginning of a line and
press Enter.  (Insert must be on.)  A new blank line will be
inserted above the line with the cursor, and the rest of the file
will be pushed downward.  The cursor will ride down with the text
pushed downward.
     The other way to insert a line is independent of the Insert
toggle.  Move the cursor to the beginning of a line and press
Ctrl-N.  A new line will appear, pushing the rest of the file
downward, but the cursor will not move down with the other text.

CTRL-N inserts a New line at the cursor position.

     There are also a number of different ways to delete text as
well.  The simplest is to use the Del (Delete) key.  Pressing
Ctrl-G performs exactly the same delete function:

Del deletes one Character to the Right of the cursor.
CTRL-G deletes one Character to the Right of the cursor.

The cursor does not move.  It "swallows" the character to its
right, and the rest of the line to its right moves over to fill
in the position left by the deleted character.
     The Backspace key can be used to delete characters to the
left of the cursor; another way it differs from Del is that the
cursor rides to the left on each deletion:

Backspace deletes one Character to the Left of the cursor.

You can think of backspace as "eating" one character to the left
as it moves the cursor leftward.
     You can also (to save a few keystrokes) delete one word to
the right of the cursor:

CTRL-T deletes one Word to the Right of the cursor.

When you press Ctrl-T, all characters from the cursor position
rightward to the end of the current word will be deleted.  If the
cursor happens to be on a space or group of spaces between words,
that space or spaces will be deleted up to the beginning of the
next word.
     It is possible to delete from the cursor position to the end
of the cursor line:

CTRL-Q/Y deletes from the cursor to The end of the line.

     And finally, it is possible to delete the entire cursor line
with a single control keystroke:

CTRL-Y deletes the entire Line containing the cursor.

The line beneath the cursor moves up to take the place of the
deleted line, pulling up the rest of the file behind it.
     A warning here for those of you with thick fingers:  The T
and Y characters are right next to one another on the keyboard. 
In a late night frenzy at the keyboard you may find yourself
reaching for Ctrl-T to delete a word and hit Ctrl-Y instead,
losing the entire line irretrievably.  I've done this often
enough that I simply broke myself of the habit of using Ctrl-T at
all.

Undoing changes to a line
JED's editor keeps a "backup" copy of each line while you're
working on it, and retains that copy as long as the cursor
remains within the line.  Therefore, if you delete a word or some
other portion of the line, or add something to a line by mistake,
you can undo those changes to the line as long as you haven't yet
left the line.  Once you leave the line even momentarily, the
editor throws away the backup copy, and Undo is no longer
possible.
     
CTRL-Q/L restores a line to its condition before you entered it.

One drawback is that the undo feature will not restore a line
deleted entirely with the Ctrl-Y command.  Once a line is
deleted, the cursor (by necessity) leaves the line, and so the
editor does not retain the backup copy of the line.  Be careful
how you use Ctrl-Y!

Markers and blocks
JED's editor supports two different kinds of markers; that is,
positions in the file that have a name or number and may be moved
around as needed by the programmer.  These are place markers and
block markers.

Place markers
There is no such thing as a page number in an editor file.  You
can move the cursor to the beginning or end of the file with a
single command, but to move to a specific place in the file is
harder.  The best way is to remember a distinctive title,
procedure name, or something like that and search for it.  (See
below.)  You might also make use the editor's place marker
feature.
     The editor supports four place markers, numbered 0-3.  These
may be placed at any position in a text file with a single
command:

CTRL-K<n> sets marker <n> within a file.  <n> may be 0-3.

For example, to set marker 2, you would press Ctrl-K2.  
     Once a place marker has been set, you can move the cursor to
it with a single command:

CTRL-Q<n> moves the cursor to marker <n>.

For example, to move to marker 2 you would type Ctrl-Q2.  If you
have two or three "construction zones" within a largish source
file, you might drop one of the place markers at the start of
each zone, so you can shuttle between the zones with a single
command.
     The markers are invisible, and if you forget where they are
about all you can do is move the cursor to them with the Ctrl-
Q<n> command.

Block markers
The other kind of marker is used to specify the beginning and end
of a text block.  There are only two of these markers, and in
consequence only one block may be marked within a file at any
given time.  These are called the block markers, and their names
are B and K, after the commands that position them in your file.
     The block markers are invisible and do not appear on your
screen in any way.  If both are present in a file, however, all
the text between them (the currently marked block) is shown as
highlighted text.
     Placing each block marker is a two-character control
keystroke:

CTRL-K/B places the B marker.  The shortcut is F7.
CTRL-K/K places the K marker.  The shortcut is F8.

Note the two function key shortcuts, which are extremely
convenient and fast. 
     A marker is placed at the cursor position and remains there
until you move it elsewhere.  You cannot delete or remove a
marker once placed, although you can "hide" the block of text
which lies between the markers, which effectively gets the
markers out of the picture. (See below for more on hiding marked
blocks.)

Moving the cursor to a block marker
There are also commands to move the cursor to the block markers,
B and K:

CTRL-Q/B moves the cursor to the B marker.
CTRL-Q/K moves the cursor to the K marker.

Hiding and un-hiding blocks of text
The major use of markers, however, is their ability to define a
block a text.  There are a number of commands available in the
JED's editor that manipulate the text that lies between the B and
K markers.
     You probably noticed while experimenting with setting
markers that as soon as you positioned both the B and K markers
in a file, the text between them became highlighted.  The
highlighted text is a marked text block.  As we mentioned before,
there is no way to remove a marker completely from a file once it
has been set.  You can, however, suppress the highlighting of
text between the two markers.  This is called "hiding" a block:

CTRL-K/H will Hide a Block of text.

Remember that the markers are still there.  Ctrl-K/H is a
toggle.  You invoke it once to hide a block, and you can invoke
it a second time to "un-hide" the block and bring out the
highlighting again on the text between the two blocks.
     Something else to keep in mind:  The other block commands
we'll be looking it below work only on highlighted blocks.  Once
a block is hidden, it is hidden from the block commands as well
as from your eyes.

Marking a word as a block
The editor includes a short form of the command sequence for
marking a single word as a block.  Ordinarily, you'd have to move
the cursor to the beginning of the word, press F7, then move to
the end of the word and press F8.  With one command you can mark
a word as a block, once you've moved the cursor to any position
within that word:

CTRL-K/T marks the word containing the cursor as a block.


Block commands
The simplest block command to understand is delete block. 
Getting rid of big chunks of text which are no longer needed is
easy:  Mark the text as a block with the two markers, and issue
the delete block command:

CTRL-K/Y will Delete a Block of text.

The markers themselves are not destroyed with the block of text. 
They "close up" and occupy the same single cursor position, but
they are still there, and you can move the cursor to them with
the Ctrl-Q/B or Ctrl-Q/K commands.
     Copy block is useful when you have some standard text
construction (a standard boilerplate comment header for
procedures, perhaps) which you need to use several times within
the same text file.  Rather than type it in each time, you type
it once, mark it as a block, and then copy it from the original
into each position where you need it.  Simply put the cursor
where the first character of the copied text must go, and issue
copy block:

CTRL-K/C will Copy a Block of text to the cursor position.

     Moving a block of text is similar to copying a block of
text.  The difference, of course, is that the original block of
text which you marked vanishes from its original position and
reappears at the cursor position.  You must first mark the text
you wish to move as a block.  Then put the cursor where you wish
the marked text to go, and issue move block:

CTRL-K/V will Move a Block of text to the cursor position.

     The last two block commands allow you to write a block of
text to disk, or to read a text file from disk into your work
file.  Writing a block to disk begins by marking the block you
want saved as a separate text file.  Then issue the write block
command:

CTRL-K/W will Write a Block of text to disk.

The editor needs to know the name of the disk file into which you
want to write the marked block of text.  It prompts you for the
file name with a dialog box entitled "Write Block To File".  You
must type the name of the file, with full path if you intend the
block to be written outside of the current directory.  Once the
name is typed and you have pressed Enter, the block is written to
disk.  The block remains highlighted, and the cursor does not
move.
     Reading a text file from disk into your work file is also
easy.  You position the cursor to where the first character of
the text from the file should go, and issue read block:

CTRL-K/R will Read a Block of text from disk to the cursor
position.

Just as with write block, the editor will prompt you for the name
of the file which you wish to read from disk with a dialog box
entitled "Read block from file".
     There is one small "gotcha" which you must be aware of in
connection with file names.  If you enter a file name without a
period or file extension (that is, a file name like FOO rather
than FOO.ASM) JED's editor will first look for a file named FOO. 
If it does not find one, it will then look for a file named
FOO.ASM.  If it cannot find a file with the entered name plus the
.ASM file extension, it will issue this error message within an
alarming red (if you have a color screen) box:

Unable to open FOO.ASM.  Press <ESC>

Pressing Esc cancels the command entirely, and to enter the name
correctly you will need to issue the Ctrl-K/R command again.
     The text file will be read and inserted into your work file
at the cursor position.  It will come in as a marked block, and
you will have to issue the hide block command to remove the
highlighting.  Remember also that reading a block of text from
disk will effectively move your two block markers from elsewhere
in your file and place them around the text which was read in.
     The editor is not especially picky about the type of files
you read from disk.  Text files need not have been generated by
JED's editor.  Files need not be text files at all, in fact; but
remember that reading raw binary data into a text file can cause
the file to appear foreshortened: The first binary 26 (Ctrl-Z)
encountered in a text file is assumed to signal the end of the
file.  Data after that first Ctrl-Z may or may not be
accessible.  Furthermore, the editor will attempt to display the
binary characters as-is, and loading (for example) an .EXE file
will fill the screen with some pretty lively garbage.

Searching and replacing
Much of the power of electronic text editing lies in its ability
to search for a particular character pattern in a text file. 
Furthermore, once found, it is a logical extension of the search
concept to replace the found text string with a different text
string.  For example, if you decide to change the name of a
variable to something else to avoid conflict with another
identifier in a program, you might wish to have the text editor
locate every instance of the old variable name in a program and
replace each one with the new variable name.
     The editor can do both search and search/replace operations
with great ease.  Simply locating a given text string in a
program is often better than having page numbering (which JED's
editor does not.)  If you wish to work on the part of a program
that contains a particular procedure, all you need do is search
for that procedure's name and you will move the cursor right to
the spot you want:

CTRL-Q/F will Find a given text string.

     When you issue the Find command, the editor prompts you with
a single word:

Find:

You must then type the text string which you wish found, ending
it by pressing Enter.  The editor then prompts you for command
options:

Options:

There are several command options which may be given to both the
find and find/replace commands.  These are single letters (or
numbers), and may be grouped together in any order without spaces
in between:

Options: BWU

for example.  We'll be discussing each option in detail shortly. 
Once you press Enter after entering the options (if any) the
editor executes the command.  For the Find command, the cursor
will move to the first character of the found text string.  If
the editor cannot find any instance of the requested text string
in the work file, it displays this message:

Search string not found. Press <ESC>

You must then press Esc to continue editing.

Find/replace
Find/replace goes that extra step further.  Once the search text
is found, it will replace the search text with a replacement
text.  The options mean everything here; you can replace only the
first instance of the search text, or all instances, and you can
have the editor ask permission before replacing, or simply go
ahead and do the deed to as many instances of the search text as
it finds.  (This last operation is especially beloved of
programmers, who call it a "search and destroy.")
     As with Find, the editor prompts for the search text and
options.  It must also (for Find/replace) prompt for the
replacement string:

Replace with:

     If no options are in force, the editor will locate the first
instance of the search string, place the cursor beneath it, and
give you the permission prompt:

Replace (Y/N):

If you type a Y here (no Enter required) the editor will perform
the replacement.  If you type an N, nothing will change.

Search/replace options
The editor's find/replace options allow you to "fine-tune" a Find
or Find/replace command to cater to specific needs.  For example,
without any options the Find command is case-sensitive.  In other
words, "FOO", "foo", and "Foo" are three distinct text strings,
and searching for "FOO" will not discover instances of "foo." 
With the U option in force, however, "FOO", "foo", and "Foo" are
considered identical and searching for any of the three forms
will turn up instances of any of the three which are present. 
There are several such options to choose from within the 
editor.  In general they are the same Find/replace options used
by WordStar.

B is the Search Backwards option.  Ordinarily, a search will
proceed from the cursor position toward the end of the file.  If
the object of the search is closer to the beginning of the file
than the cursor, the search will not find it.  With the B option
in force, the search proceeds backwards through the file, toward
the beginning.

G is the Global Search option.  As mentioned above, searches
normally begin at the cursor position and proceed toward one end
of the file or the other, depending on whether or not the B
option is in force.  With the G option in force, searches begin
at the beginning of the file and proceed to the end, irrespective
of the cursor position.  The G option overrides the B option.

N is the Replace Without Asking option.  Without this option, the
editor (during a Find/replace) will prompt you for a yes/no
response each time it locates an instance of the search text. 
With N in force, it simply does the replacement.  Combining the G
and N options means that the editor will search the entire file
and replace every instance of the search text with the
replacement text, without asking.  Make sure you set it up right,
or you can cause wholesale damage to your work file.  In general,
don't use G and N together without W.  (See below for details on
the W option.)

U is the Ignore Case option.  Without this option, searches are
case-sensitive.  "FOO" and "foo" are considered distinct and
searching for one will not find the other.  With the U option in
force, corresponding lower and upper case characters are
considered identical.  "FOO" and "foo" will both be found on a
search for either.

W is the Whole Words option.  Without this option, the search
text will be found even when it is embedded in a larger word. 
For example, searching for "LOCK" will find both "BLOCK" and
"CLOCK".  With W in force, the search text must be bounded by
spaces to be found.  This option is especially important for
global Find/replace commands, when (if you omit W) replacing all
instances of "LOCK" with "SECURE" will change all instances of
"BLOCK" to "BSECURE" and all instances of "CLOCK" to "CSECURE".  
     You may also give a number as one of the options.  For the
Find command, this tells the editor to find the nth instance of
the search text.  For Find/replace, a number tells the editor to
find and replace text n times.

Find or find/replace again
The editor remembers what the last Find or Find/replace command
was, search text, replacement text, options, and all.  You can
execute that last Find or Find/replace command again simply by
issuing the Find or Find/replace again command:

CTRL-L will perform the last Find or Find/replace command Again.

     Ctrl-L can save you some considerable keystroking.  Suppose,
for example, you wanted to examine the header line of every
procedure in a large (perhaps 1000 line) program with thirty or
forty procedures.  The way to do it is to search for the string
"PROC" with the G, U, and  W options in effect.  The first
invocation of this command will find the first procedure in your
program file.  To find the next one, simply press Ctrl-L.  You
need not re-enter the search text "PROC" or the options.  Each
time you press Ctrl-L, the editor will find the next instance of
the reserved word "PROC" until it runs out of file, or until you
issue a new and different Find or Find/replace command.

Saving your work
It is very important to keep in mind what is happening while you
edit text files with the editor.  You are editing entirely within
memory.  Nothing goes out to disk while you are actually doing
the edit.  You can work on a file for hours, and one power
failure will throw it all away.  You must develop the discipline
of saving your work every so often.
     The easiest way to execute a Save command from within the
editor is with the Save shortcut, F2.  The "longcut" to saving
the file from within the editor is Ctrl-K/S, (useful if you have
WordStar burned into your synapses) but F2 is easier to type and
remember.

F2 or Ctrl-K/S always Save your work file.

Exiting the editor
There is more than one way to get out of JED once you're finished
with the job at hand.  You can get out with any of these
commands:

Ctrl-K/D saves the current file, and Exits to DOS.
Ctrl-K/Q ends the edit without saving, and Exits to DOS.
Alt-X saves the current file if necessary and Exits to DOS.

The differences between them are subtle.  Ctrl-K/D always saves
the current file, and exits to DOS, whether the file has been
modified or not.  If the current file is very large, this can
mean a delay of several seconds while the file is written out to
disk, especially if you're working from diskettes.
     Ctrl-KQ, on the other hand, may be used to exit from JED
without saving the current file, even if the current file has
been modified since it was last saved.  JED, always the one for
safety, will ask you if you want to abandon the changes you've
made.  You can answer only Y or N; Y will indeed exit to DOS
without saving the current file.  N, on the other hand, indicates
a change of heart on your part and JED will save the current file
to disk.
     Finally, Alt-X is the smart way out.  If you made changes to
the current file since the last time it was saved to disk, JED
will save the file to disk.  If no changes were made, JED will
not waste your time with an unnecessary save, but will drop you
out to disk immediately.
     No matter how you exit to DOS, JED considerately restores
the DOS screen that existed just before you invoked it.
     One important use of Ctrl-KQ is to "undo" a disastrous
search-and-destroy operation that went bad using Ctrl-Q/A.  If
you've changed every one of 677 instances of MOV to MUV by
accident, and haven't yet saved the damaged file to disk using
F2, your only course of action is to exit to DOS without saving
the damaged file to disk.  That done, you can re-enter JED and
the last undamaged version of the current file will be reloaded
and ready for you to try again.
     So be careful, huh?
